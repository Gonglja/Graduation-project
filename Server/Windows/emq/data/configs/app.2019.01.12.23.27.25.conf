##====================================================================
## EMQ X Configuration R3.0
##====================================================================

##--------------------------------------------------------------------
## Cluster
##--------------------------------------------------------------------

## Cluster name.
##
## Value: String
cluster.name = emqxcl

## Cluster auto-discovery strategy.
##
## Value: Enum
## - manual: Manual join command
## - static: Static node list
## - mcast:  IP Multicast
## - dns:    DNS A Record
## - etcd:   etcd
## - k8s:    Kubernates
##
## Default: manual
cluster.discovery = manual

## Enable cluster autoheal from network partition.
##
## Value: on | off
##
## Default: on
cluster.autoheal = on

## Autoclean down node. A down node will be removed from the cluster
## if this value > 0.
##
## Value: Duration
## -h: hour, e.g. '2h' for 2 hours
## -m: minute, e.g. '5m' for 5 minutes
## -s: second, e.g. '30s' for 30 seconds
##
## Default: 5m
cluster.autoclean = 5m

##--------------------------------------------------------------------
## Cluster using static node list

## Node list of the cluster.
##
## Value: String
## cluster.static.seeds = emqx1@127.0.0.1,emqx2@127.0.0.1

##--------------------------------------------------------------------
## Cluster using IP Multicast.

## IP Multicast Address.
##
## Value: IP Address
## cluster.mcast.addr = 239.192.0.1

## Multicast Ports.
##
## Value: Port List
## cluster.mcast.ports = 4369,4370

## Multicast Iface.
##
## Value: Iface Address
##
## Default: 0.0.0.0
## cluster.mcast.iface = 0.0.0.0

## Multicast Ttl.
##
## Value: 0-255
## cluster.mcast.ttl = 255

## Multicast loop.
##
## Value: on | off
## cluster.mcast.loop = on

##--------------------------------------------------------------------
## Cluster using DNS A records.

## DNS name.
##
## Value: String
## cluster.dns.name = localhost

## The App name is used to build 'node.name' with IP address.
##
## Value: String
## cluster.dns.app = emqx

##--------------------------------------------------------------------
## Cluster using etcd

## Etcd server list, seperated by ','.
##
## Value: String
## cluster.etcd.server = http://127.0.0.1:2379

## The prefix helps build nodes path in etcd. Each node in the cluster
## will create a path in etcd: v2/keys/<prefix>/<cluster.name>/<node.name>
##
## Value: String
## cluster.etcd.prefix = emqxcl

## The TTL for node's path in etcd.
##
## Value: Duration
##
## Default: 1m, 1 minute
## cluster.etcd.node_ttl = 1m

##--------------------------------------------------------------------
## Cluster using Kubernates

## Kubernates API server list, seperated by ','.
##
## Value: String
## cluster.k8s.apiserver = http://10.110.111.204:8080

## The service name helps lookup EMQ nodes in the cluster.
##
## Value: String
## cluster.k8s.service_name = emqx

## The address type is used to extract host from k8s service.
##
## Value: ip | dns
## cluster.k8s.address_type = ip

## The app name helps build 'node.name'.
##
## Value: String
## cluster.k8s.app_name = emqx

## Kubernates Namespace
##
## Value: String
## cluster.k8s.namespace = default

##--------------------------------------------------------------------
## Node
##--------------------------------------------------------------------

## Node name.
##
## See: http://erlang.org/doc/reference_manual/distributed.html
##
## Value: <name>@<host>
##
## Default: emqx@127.0.0.1
node.name = emqx@127.0.0.1

## Cookie for distributed node communication.
##
## Value: String
node.cookie = emqxsecretcookie

## Enable SMP support of Erlang VM.
##
## Value: enable | auto | disable
node.smp = auto

## Heartbeat monitoring of an Erlang runtime system. Comment the line to disable
## heartbeat, or set the value as 'on'
##
## Value: on
##
## vm.args: -heart
## node.heartbeat = on

## Enable kernel poll.
##
## Value: on | off
##
## Default: on
node.kernel_poll = on

## Sets the number of threads in async thread pool. Valid range is 0-1024.
##
## See: http://erlang.org/doc/man/erl.html
##
## Value: 0-1024
##
## vm.args: +A Number
node.async_threads = 32

## Sets the maximum number of simultaneously existing processes for this
## system if a Number is passed as value.
##
## See: http://erlang.org/doc/man/erl.html
##
## Value: Number [1024-134217727]
##
## vm.args: +P Number
node.process_limit = 2048000

## Sets the maximum number of simultaneously existing ports for this system.
##
## See: http://erlang.org/doc/man/erl.html
##
## Value: Number [1024-134217727]
##
## vm.args: +Q Number
node.max_ports = 1024000

## Set the distribution buffer busy limit (dist_buf_busy_limit).
##
## See: http://erlang.org/doc/man/erl.html
##
## Value: Number [1KB-2GB]
##
## vm.args: +zdbbl size
node.dist_buffer_size = 8MB

## Sets the maximum number of ETS tables. Note that mnesia and SSL will
## create temporary ETS tables.
##
## Value: Number
##
## vm.args: +e Number
node.max_ets_tables = 256000

## Tweak GC to run more often.
##
## Value: Number [0-65535]
##
## vm.args: -env ERL_FULLSWEEP_AFTER Number
node.fullsweep_after = 1000

## Crash dump log file.
##
## Value: Log file
node.crash_dump = log/crash.dump

## Specify the erlang distributed protocol.
##
## Value: Enum
##  - inet_tcp: the default; handles TCP streams with IPv4 addressing.
##  - inet6_tcp: handles TCP with IPv6 addressing.
##  - inet_tls: using TLS for Erlang Distribution.
##
## vm.args: -proto_dist inet_tcp
node.proto_dist = inet_tcp

## Specify SSL Options in the file if using SSL for Erlang Distribution.
##
## Value: File
##
## vm.args: -ssl_dist_optfile <File>
## node.ssl_dist_optfile = etc/ssl_dist.conf

## Sets the net_kernel tick time. TickTime is specified in seconds.
## Notice that all communicating nodes are to have the same TickTime
## value specified.
##
## See: http://www.erlang.org/doc/man/kernel_app.html#net_ticktime
##
## Value: Number
##
## vm.args: -kernel net_ticktime Number
node.dist_net_ticktime = 60

## Sets the port range for the listener socket of a distributed Erlang node.
## Note that if there are firewalls between clustered nodes, this port segment
## for nodes’ communication should be allowed.
##
## See: http://www.erlang.org/doc/man/kernel_app.html
##
## Value: Port [1024-65535]
node.dist_listen_min = 6369
node.dist_listen_max = 6369

##--------------------------------------------------------------------
## RPC
##--------------------------------------------------------------------

## TCP server port for RPC.
##
## Value: Port [1024-65535]
rpc.tcp_server_port = 5369

## TCP port for outgoing RPC connections.
##
## Value: Port [1024-65535]
rpc.tcp_client_port = 5369

## RCP Client connect timeout.
##
## Value: Seconds
rpc.connect_timeout = 5000

## TCP send timeout of RPC client and server.
##
## Value: Seconds
rpc.send_timeout = 5000

## Authentication timeout
##
## Value: Seconds
rpc.authentication_timeout = 5000

## Default receive timeout for call() functions
##
## Value: Seconds
rpc.call_receive_timeout = 15000

## Socket idle keepalive.
##
## Value: Seconds
rpc.socket_keepalive_idle = 900

## TCP Keepalive probes interval.
##
## Value: Integer
rpc.socket_keepalive_interval = 75

## Probes lost to close the connection
##
## Value: Integer
rpc.socket_keepalive_count = 9

##--------------------------------------------------------------------
## Log
##--------------------------------------------------------------------

## Where to emit the logs.
## Enable the console (standard output) logs.
##
## Value: off | file | console | both
## - off: disable logs entirely
## - file: write logs only to file
## - console: write logs only to standard I/O
## - both: write logs both to file and standard I/O
log.to = both

## The log severity level.
##
## Value: debug | info | notice | warning | error | critical | alert | emergency
##
## Note: Only the messages with severity level higher than or equal to
##       this level will be logged.
##
## Default: error
log.level = error

## The dir for log files.
##
## Value: Folder
log.dir = log

## The log filename for logs of level specified in "log.level".
##
## Value: String
## Default: emqx.log
log.file = emqx.log

## Maximum size of each log file.
##
## Value: Number
## Default: 10M
## Supported Unit: KB | MB | G
log.rotation.size = 10MB

## Maximum rotation count of log files.
##
## Value: Number
## Default: 5
log.rotation.count = 5

## To create additional log files for specific log levels.
##
## Value: File Name
## Format: log.$level.file = $filename,
##         where "$level" can be one of: debug, info, notice, warning,
##                                       error, critical, alert, emergency
## Note: Log files for a specific log level will only contain all the logs
##       that higher than or equal to that level
##

#log.info.file = info.log
#log.error.file = error.log

##--------------------------------------------------------------------
## Authentication/Access Control
##--------------------------------------------------------------------

## Allow anonymous authentication by default if no auth plugins loaded.
## Notice: Disable the option in production deployment!
##
## Value: true | false
allow_anonymous = true

## Allow or deny if no ACL rules matched.
##
## Value: allow | deny
acl_nomatch = allow

## Default ACL File.
##
## Value: File Name
acl_file = etc/acl.conf

## Whether to enable ACL cache.
##
## If enabled, ACLs roles for each client will be cached in the memory
##
## Value: on | off
enable_acl_cache = on

## The maximum count of ACL entries can be cached for a client.
##
## Value: Integer greater than 0
## Default: 32
acl_cache_max_size = 32

## The time after which an ACL cache entry will be deleted
##
## Value: Duration
## Default: 1 minute
acl_cache_ttl = 1m

## The action when acl check reject current operation
##
## Value: ignore | disconnect
## Default: ignore
acl_deny_action = ignore

##--------------------------------------------------------------------
## MQTT Protocol
##--------------------------------------------------------------------

## Response Topic Prefix
##
## Value: String
## Default: emqxrspv1
mqtt.response_topic_prefix = emqxrspv1

## Maximum MQTT packet size allowed.
##
## Value: Bytes
## Default: 1MB
mqtt.max_packet_size = 1MB

## Maximum length of MQTT clientId allowed.
##
## Value: Number [23-65535]
mqtt.max_clientid_len = 65535

## Maximum topic levels allowed. 0 means no limit.
##
## Value: Number
mqtt.max_topic_levels = 0

## Maximum QoS allowed.
##
## Value: 0 | 1 | 2
mqtt.max_qos_allowed = 2

## Maximum Topic Alias, 0 means no topic alias supported.
##
## Value: 0-65535
mqtt.max_topic_alias = 0

## Whether the Server supports MQTT retained messages.
##
## Value: boolean
mqtt.retain_available = true

## Whether the Server supports MQTT Wildcard Subscriptions
##
## Value: boolean
mqtt.wildcard_subscription = true

## Whether the Server supports MQTT Shared Subscriptions.
##
## Value: boolean
mqtt.shared_subscription = true

## Whether to ignore loop delivery of messages.(for mqtt v3.1.1)
##
## Value: true | false
mqtt.ignore_loop_deliver = false

##--------------------------------------------------------------------
## Zones
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## External Zone

## Idle timeout of the external MQTT connections.
##
## Value: duration
zone.external.idle_timeout = 15s

## Publish limit for the external MQTT connections.
##
## Value: Number,Duration
## Example: 10 messages per minute.
## zone.external.publish_limit = 10,1m

## Enable ACL check.
##
## Value: Flag
zone.external.enable_acl = on

## Enable ban check.
##
## Value: Flag
zone.external.enable_ban = on

## Enable per connection statistics.
##
## Value: on | off
zone.external.enable_stats = on

## The action when acl check reject current operation
##
## Value: ignore | disconnect
## Default: ignore
zone.external.acl_deny_action = ignore

## Force MQTT connection/session process GC after this number of
## messages | bytes passed through.
##
## Numbers delimited by `|'. Zero or negative is to disable.
zone.external.force_gc_policy = 1000|1MB

## Maximum MQTT packet size allowed.
##
## Value: Bytes
## Default: 1MB
## zone.external.max_packet_size = 64KB

## Maximum length of MQTT clientId allowed.
##
## Value: Number [23-65535]
## zone.external.max_clientid_len = 1024

## Maximum topic levels allowed. 0 means no limit.
##
## Value: Number
## zone.external.max_topic_levels = 7

## Maximum QoS allowed.
##
## Value: 0 | 1 | 2
## zone.external.max_qos_allowed = 2

## Maximum Topic Alias, 0 means no limit.
##
## Value: 0-65535
## zone.external.max_topic_alias = 0

## Whether the Server supports retained messages.
##
## Value: boolean
## zone.external.retain_available = true

## Whether the Server supports Wildcard Subscriptions
##
## Value: boolean
## zone.external.wildcard_subscription = false

## Whether the Server supports Shared Subscriptions
##
## Value: boolean
## zone.external.shared_subscription = false

## Server Keep Alive
##
## Value: Number
## zone.external.server_keepalive = 0

## The backoff for MQTT keepalive timeout. The broker will kick a connection out
## until 'Keepalive * backoff * 2' timeout.
##
## Value: Float > 0.5
zone.external.keepalive_backoff = 0.75

## Maximum number of subscriptions allowed, 0 means no limit.
##
## Value: Number
zone.external.max_subscriptions = 0

## Force to upgrade QoS according to subscription.
##
## Value: on | off
zone.external.upgrade_qos = off

## Maximum size of the Inflight Window storing QoS1/2 messages delivered but unacked.
##
## Value: Number
zone.external.max_inflight = 32

## Retry interval for QoS1/2 message delivering.
##
## Value: Duration
zone.external.retry_interval = 20s

## Maximum QoS2 packets (Client -> Broker) awaiting PUBREL, 0 means no limit.
##
## Value: Number
zone.external.max_awaiting_rel = 100

## The QoS2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout.
##
## Value: Duration
zone.external.await_rel_timeout = 300s

## Default session expiry interval for MQTT V3.1.1 connections.
##
## Value: Duration
## -d: day
## -h: hour
## -m: minute
## -s: second
##
## Default: 2h, 2 hours
zone.external.session_expiry_interval = 2h

## Maximum queue length. Enqueued messages when persistent client disconnected,
## or inflight window is full. 0 means no limit.
##
## Value: Number >= 0
zone.external.max_mqueue_len = 1000

## Topic priorities.
## 'none' to indicate no priority table (by default), hence all messages
## are treated equal
##
## Priority number [1-255]
## Example: topic/1=10,topic/2=8
## NOTE: comma and equal signs are not allowed for priority topic names
## NOTE: messages for topics not in the priority table are treated as
##       either highest or lowest priority depending on the configured
##       value for mqueue_default_priority
##
zone.external.mqueue_priorities = none

## Default to highest priority for topics not matching priority table
##
## Value: highest | lowest
zone.external.mqueue_default_priority = highest

## Whether to enqueue Qos0 messages.
##
## Value: false | true
zone.external.mqueue_store_qos0 = true

## All the topics will be prefixed with the mountpoint path if this option is enabled.
##
## Variables in mountpoint path:
##  - %c: clientid
##  - %u: username
##
## Value: String
## zone.external.mountpoint = devicebound/

## Whether use username replace client id
##
## Value: boolean
## Default: false
zone.external.use_username_as_clientid = false

##--------------------------------------------------------------------
## Internal Zone

zone.internal.allow_anonymous = true

## Enable per connection stats.
##
## Value: Flag
zone.internal.enable_stats = on

## Enable ACL check.
##
## Value: Flag
zone.internal.enable_acl = off

## The action when acl check reject current operation
##
## Value: ignore | disconnect
## Default: ignore
zone.internal.acl_deny_action = ignore

## See zone.$name.wildcard_subscription.
##
## Value: boolean
## zone.internal.wildcard_subscription = true

## See zone.$name.shared_subscription.
##
## Value: boolean
## zone.internal.shared_subscription = true

## See zone.$name.max_subscriptions.
##
## Value: Integer
zone.internal.max_subscriptions = 0

## See zone.$name.max_inflight
##
## Value: Number
zone.internal.max_inflight = 32

## See zone.$name.max_awaiting_rel
##
## Value: Number
zone.internal.max_awaiting_rel = 100

## See zone.$name.max_mqueue_len
##
## Value: Number >= 0
zone.internal.max_mqueue_len = 1000

## Whether to enqueue Qos0 messages.
##
## Value: false | true
zone.internal.mqueue_store_qos0 = true

## All the topics will be prefixed with the mountpoint path if this option is enabled.
##
## Variables in mountpoint path:
##  - %c: clientid
##  - %u: username
##
## Value: String
## zone.internal.mountpoint = cloudbound/

## Whether use username replace client id
##
## Value: boolean
## Default: false
zone.internal.use_username_as_clientid = false

##--------------------------------------------------------------------
## Listeners
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## MQTT/TCP - External TCP Listener for MQTT Protocol

## listener.tcp.$name is the IP address and port that the MQTT/TCP
## listener will bind.
##
## Value: IP:Port | Port
##
## Examples: 1883, 127.0.0.1:1883, ::1:1883
listener.tcp.external = 0.0.0.0:1883

## The acceptor pool for external MQTT/TCP listener.
##
## Value: Number
listener.tcp.external.acceptors = 8

## Maximum number of concurrent MQTT/TCP connections.
##
## Value: Number
listener.tcp.external.max_connections = 1024000

## Maximum external connections per second.
##
## Value: Number
listener.tcp.external.max_conn_rate = 1000

## Specify the {active, N} option for the external MQTT/TCP Socket.
##
## Value: Number
listener.tcp.external.active_n = 100

## Zone of the external MQTT/TCP listener belonged to.
##
## See: zone.$name.*
##
## Value: String
listener.tcp.external.zone = external

## Mountpoint of the MQTT/TCP Listener. All the topics will be prefixed
## with the mountpoint path if this option is enabled.
##
## Variables in mountpoint path:
##  - %c: clientid
##  - %u: username
##
## Value: String
## listener.tcp.external.mountpoint = devicebound/

## Rate limit for the external MQTT/TCP connections. Format is 'rate,burst'.
##
## Value: rate,burst
## Unit: Bps
## listener.tcp.external.rate_limit = 1024,4096

## The access control rules for the MQTT/TCP listener.
##
## See: https://github.com/emqtt/esockd#allowdeny
##
## Value: ACL Rule
##
## Example: allow 192.168.0.0/24
listener.tcp.external.access.1 = allow all

## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
## behind HAProxy or Nginx.
##
## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
##
## Value: on | off
## listener.tcp.external.proxy_protocol = on

## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
## if no proxy protocol packet recevied within the timeout.
##
## Value: Duration
## listener.tcp.external.proxy_protocol_timeout = 3s

## Enable the option for X.509 certificate based authentication.
## EMQX will use the common name of certificate as MQTT username.
##
## Value: cn | dn
## listener.tcp.external.peer_cert_as_username = cn

## The TCP backlog defines the maximum length that the queue of pending
## connections can grow to.
##
## Value: Number >= 0
listener.tcp.external.backlog = 1024

## The TCP send timeout for external MQTT connections.
##
## Value: Duration
listener.tcp.external.send_timeout = 15s

## Close the TCP connection if send timeout.
##
## Value: on | off
listener.tcp.external.send_timeout_close = on

## The TCP receive buffer(os kernel) for MQTT connections.
##
## See: http://erlang.org/doc/man/inet.html
##
## Value: Bytes
## listener.tcp.external.recbuf = 2KB

## The TCP send buffer(os kernel) for MQTT connections.
##
## See: http://erlang.org/doc/man/inet.html
##
## Value: Bytes
## listener.tcp.external.sndbuf = 2KB

## The size of the user-level software buffer used by the driver.
## Not to be confused with options sndbuf and recbuf, which correspond
## to the Kernel socket buffers. It is recommended to have val(buffer)
## >= max(val(sndbuf),val(recbuf)) to avoid performance issues because
## of unnecessary copying. val(buffer) is automatically set to the above
## maximum when values sndbuf or recbuf are set.
##
## See: http://erlang.org/doc/man/inet.html
##
## Value: Bytes
## listener.tcp.external.buffer = 2KB

## Sets the 'buffer = max(sndbuf, recbuf)' if this option is enabled.
##
## Value: on | off
## listener.tcp.external.tune_buffer = off

## The TCP_NODELAY flag for MQTT connections. Small amounts of data are
## sent immediately if the option is enabled.
##
## Value: true | false
listener.tcp.external.nodelay = true

## The SO_REUSEADDR flag for TCP listener.
##
## Value: true | false
listener.tcp.external.reuseaddr = true

##--------------------------------------------------------------------
## Internal TCP Listener for MQTT Protocol

## The IP address and port that the internal MQTT/TCP protocol listener
## will bind.
##
## Value: IP:Port, Port
##
## Examples: 11883, 127.0.0.1:11883, ::1:11883
listener.tcp.internal = 127.0.0.1:11883

## The acceptor pool for internal MQTT/TCP listener.
##
## Value: Number
listener.tcp.internal.acceptors = 4

## Maximum number of concurrent MQTT/TCP connections.
##
## Value: Number
listener.tcp.internal.max_connections = 1024000

## Maximum internal connections per second.
##
## Value: Number
listener.tcp.internal.max_conn_rate = 1000

## Specify the {active, N} option for the internal MQTT/TCP Socket.
##
## Value: Number
listener.tcp.internal.active_n = 1000

## Zone of the internal MQTT/TCP listener belonged to.
##
## Value: String
listener.tcp.internal.zone = internal

## Mountpoint of the MQTT/TCP Listener.
##
## See: listener.tcp.$name.mountpoint
##
## Value: String
## listener.tcp.internal.mountpoint = internal/

## Rate limit for the internal MQTT/TCP connections.
##
## See: listener.tcp.$name.rate_limit
##
## Value: rate,burst
## Unit: Bps
## listener.tcp.internal.rate_limit = 1000000,2000000

## The TCP backlog of internal MQTT/TCP Listener.
##
## See: listener.tcp.$name.backlog
##
## Value: Number >= 0
listener.tcp.internal.backlog = 512

## The TCP send timeout for internal MQTT connections.
##
## See: listener.tcp.$name.send_timeout
##
## Value: Duration
listener.tcp.internal.send_timeout = 5s

## Close the MQTT/TCP connection if send timeout.
##
## See: listener.tcp.$name.send_timeout_close
##
## Value: on | off
listener.tcp.external.send_timeout_close = on

## The TCP receive buffer(os kernel) for internal MQTT connections.
##
## See: listener.tcp.$name.recbuf
##
## Value: Bytes
## listener.tcp.internal.recbuf = 16KB

## The TCP send buffer(os kernel) for internal MQTT connections.
##
## See: http://erlang.org/doc/man/inet.html
##
## Value: Bytes
## listener.tcp.internal.sndbuf = 16KB

## The size of the user-level software buffer used by the driver.
##
## See: listener.tcp.$name.buffer
##
## Value: Bytes
## listener.tcp.internal.buffer = 16KB

## Sets the 'buffer = max(sndbuf, recbuf)' if this option is enabled.
##
## See: listener.tcp.$name.tune_buffer
##
## Value: on | off
## listener.tcp.internal.tune_buffer = off

## The TCP_NODELAY flag for internal MQTT connections.
##
## See: listener.tcp.$name.nodelay
##
## Value: true | false
listener.tcp.internal.nodelay = false

## The SO_REUSEADDR flag for MQTT/TCP Listener.
##
## Value: true | false
listener.tcp.internal.reuseaddr = true

##--------------------------------------------------------------------
## MQTT/SSL - External SSL Listener for MQTT Protocol

## listener.ssl.$name is the IP address and port that the MQTT/SSL
## listener will bind.
##
## Value: IP:Port | Port
##
## Examples: 8883, 127.0.0.1:8883, ::1:8883
listener.ssl.external = 8883

## The acceptor pool for external MQTT/SSL listener.
##
## Value: Number
listener.ssl.external.acceptors = 16

## Maximum number of concurrent MQTT/SSL connections.
##
## Value: Number
listener.ssl.external.max_connections = 102400

## Maximum MQTT/SSL connections per second.
##
## Value: Number
listener.ssl.external.max_conn_rate = 500

## Specify the {active, N} option for the internal MQTT/SSL Socket.
##
## Value: Number
listener.ssl.external.active_n = 100

## Zone of the external MQTT/SSL listener belonged to.
##
## Value: String
listener.ssl.external.zone = external

## Mountpoint of the MQTT/SSL Listener.
##
## Value: String
## listener.ssl.external.mountpoint = devicebound/

## The access control rules for the MQTT/SSL listener.
##
## See: listener.tcp.$name.access
##
## Value: ACL Rule
listener.ssl.external.access.1 = allow all

## Rate limit for the external MQTT/SSL connections.
##
## Value: rate,burst
## Unit: Bps
## listener.ssl.external.rate_limit = 1024,4096

## Enable the Proxy Protocol V1/2 if the EMQ cluster is deployed behind
## HAProxy or Nginx.
##
## See: listener.tcp.$name.proxy_protocol
##
## Value: on | off
## listener.ssl.external.proxy_protocol = on

## Sets the timeout for proxy protocol.
##
## See: listener.tcp.$name.proxy_protocol_timeout
##
## Value: Duration
## listener.ssl.external.proxy_protocol_timeout = 3s

## TLS versions only to protect from POODLE attack.
##
## See: http://erlang.org/doc/man/ssl.html
##
## Value: String, seperated by ','
## listener.ssl.external.tls_versions = tlsv1.2,tlsv1.1,tlsv1

## TLS Handshake timeout.
##
## Value: Duration
listener.ssl.external.handshake_timeout = 15s

## Path to the file containing the user's private PEM-encoded key.
##
## See: http://erlang.org/doc/man/ssl.html
##
## Value: File
listener.ssl.external.keyfile = etc/certs/key.pem

## Path to a file containing the user certificate.
##
## See: http://erlang.org/doc/man/ssl.html
##
## Value: File
listener.ssl.external.certfile = etc/certs/cert.pem

## Path to the file containing PEM-encoded CA certificates. The CA certificates
## are used during server authentication and when building the client certificate chain.
##
## Value: File
## listener.ssl.external.cacertfile = etc/certs/cacert.pem

## The Ephemeral Diffie-Helman key exchange is a very effective way of
## ensuring Forward Secrecy by exchanging a set of keys that never hit
## the wire. Since the DH key is effectively signed by the private key,
## it needs to be at least as strong as the private key. In addition,
## the default DH groups that most of the OpenSSL installations have
## are only a handful (since they are distributed with the OpenSSL
## package that has been built for the operating system it’s running on)
## and hence predictable (not to mention, 1024 bits only).
## In order to escape this situation, first we need to generate a fresh,
## strong DH group, store it in a file and then use the option above,
## to force our SSL application to use the new DH group. Fortunately,
## OpenSSL provides us with a tool to do that. Simply run:
## openssl dhparam -out dh-params.pem 2048
##
## Value: File
## listener.ssl.external.dhfile = etc/certs/dh-params.pem

## A server only does x509-path validation in mode verify_peer,
## as it then sends a certificate request to the client (this
## message is not sent if the verify option is verify_none).
## You can then also want to specify option fail_if_no_peer_cert.
## More information at: http://erlang.org/doc/man/ssl.html
##
## Value: verify_peer | verify_none
## listener.ssl.external.verify = verify_peer

## Used together with {verify, verify_peer} by an SSL server. If set to true,
## the server fails if the client does not have a certificate to send, that is,
## sends an empty certificate.
##
## Value: true | false
## listener.ssl.external.fail_if_no_peer_cert = true

## This is the single most important configuration option of an Erlang SSL
## application. Ciphers (and their ordering) define the way the client and
## server encrypt information over the wire, from the initial Diffie-Helman
## key exchange, the session key encryption ## algorithm and the message
## digest algorithm. Selecting a good cipher suite is critical for the
## application’s data security, confidentiality and performance.
##
## The cipher list above offers:
##
## A good balance between compatibility with older browsers.
## It can get stricter for Machine-To-Machine scenarios.
## Perfect Forward Secrecy.
## No old/insecure encryption and HMAC algorithms
##
## Most of it was copied from Mozilla’s Server Side TLS article
##
## Value: Ciphers
listener.ssl.external.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA

## SSL parameter renegotiation is a feature that allows a client and a server
## to renegotiate the parameters of the SSL connection on the fly.
## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
## you drop support for the insecure renegotiation, prone to MitM attacks.
##
## Value: on | off
## listener.ssl.external.secure_renegotiate = off

## A performance optimization setting, it allows clients to reuse
## pre-existing sessions, instead of initializing new ones.
## Read more about it here.
##
## See: http://erlang.org/doc/man/ssl.html
##
## Value: on | off
## listener.ssl.external.reuse_sessions = on

## An important security setting, it forces the cipher to be set based
## on the server-specified order instead of the client-specified order,
## hence enforcing the (usually more properly configured) security
## ordering of the server administrator.
##
## Value: on | off
## listener.ssl.external.honor_cipher_order = on

## Use the CN, EN or CRT field from the client certificate as a username.
## Notice that 'verify' should be set as 'verify_peer'.
##
## Value: cn | en | crt
## listener.ssl.external.peer_cert_as_username = cn

## TCP backlog for the SSL connection.
##
## See listener.tcp.$name.backlog
##
## Value: Number >= 0
## listener.ssl.external.backlog = 1024

## The TCP send timeout for the SSL connection.
##
## See listener.tcp.$name.send_timeout
##
## Value: Duration
## listener.ssl.external.send_timeout = 15s

## Close the SSL connection if send timeout.
##
## See: listener.tcp.$name.send_timeout_close
##
## Value: on | off
## listener.ssl.external.send_timeout_close = on

## The TCP receive buffer(os kernel) for the SSL connections.
##
## See: listener.tcp.$name.recbuf
##
## Value: Bytes
## listener.ssl.external.recbuf = 4KB

## The TCP send buffer(os kernel) for internal MQTT connections.
##
## See: listener.tcp.$name.sndbuf
##
## Value: Bytes
## listener.ssl.external.sndbuf = 4KB

## The size of the user-level software buffer used by the driver.
##
## See: listener.tcp.$name.buffer
##
## Value: Bytes
## listener.ssl.external.buffer = 4KB

## Sets the 'buffer = max(sndbuf, recbuf)' if this option is enabled.
##
## See: listener.tcp.$name.tune_buffer
##
## Value: on | off
## listener.ssl.external.tune_buffer = off

## The TCP_NODELAY flag for SSL connections.
##
## See: listener.tcp.$name.nodelay
##
## Value: true | false
## listener.ssl.external.nodelay = true

## The SO_REUSEADDR flag for MQTT/SSL Listener.
##
## Value: true | false
listener.ssl.external.reuseaddr = true

##--------------------------------------------------------------------
## External WebSocket listener for MQTT protocol

## listener.ws.$name is the IP address and port that the MQTT/WebSocket
## listener will bind.
##
## Value: IP:Port | Port
##
## Examples: 8083, 127.0.0.1:8083, ::1:8083
listener.ws.external = 8083

## The path of WebSocket MQTT endpoint
##
## Value: URL Path
listener.ws.external.mqtt_path = /mqtt

## The acceptor pool for external MQTT/WebSocket listener.
##
## Value: Number
listener.ws.external.acceptors = 4

## Maximum number of concurrent MQTT/WebSocket connections.
##
## Value: Number
listener.ws.external.max_connections = 102400

## Maximum MQTT/WebSocket connections per second.
##
## Value: Number
listener.ws.external.max_conn_rate = 1000

## Rate limit for the MQTT/WebSocket connections.
##
## Value: rate,burst
## Unit: Bps
## listener.ws.external.rate_limit = 1024,4096

## Zone of the external MQTT/WebSocket listener belonged to.
##
## Value: String
listener.ws.external.zone = external

## Mountpoint of the MQTT/WebSocket Listener.
##
## See: listener.tcp.$name.mountpoint
##
## Value: String
## listener.ws.external.mountpoint = devicebound/

## The access control for the MQTT/WebSocket listener.
##
## See: listener.tcp.$name.access
##
## Value: ACL Rule
listener.ws.external.access.1 = allow all

## Verify if the protocol header is valid. Turn off for WeChat MiniApp.
##
## Value: on | off
listener.ws.external.verify_protocol_header = on

## Use X-Forwarded-For header for real source IP if the EMQ X cluster is
## deployed behind NGINX or HAProxy.
##
## Value: String
## listener.ws.external.proxy_address_header = X-Forwarded-For

## Use X-Forwarded-Port header for real source port if the EMQ X cluster is
## deployed behind NGINX or HAProxy.
##
## Value: String
## listener.ws.external.proxy_port_header = X-Forwarded-Port

## Enable the Proxy Protocol V1/2 if the EMQ cluster is deployed behind
## HAProxy or Nginx.
##
## See: listener.tcp.$name.proxy_protocol
##
## Value: on | off
## listener.ws.external.proxy_protocol = on

## Sets the timeout for proxy protocol.
##
## See: listener.tcp.$name.proxy_protocol_timeout
##
## Value: Duration
## listener.ws.external.proxy_protocol_timeout = 3s

## The TCP backlog of external MQTT/WebSocket Listener.
##
## See: listener.tcp.$name.backlog
##
## Value: Number >= 0
listener.ws.external.backlog = 1024

## The TCP send timeout for external MQTT/WebSocket connections.
##
## See: listener.tcp.$name.send_timeout
##
## Value: Duration
listener.ws.external.send_timeout = 15s

## Close the MQTT/WebSocket connection if send timeout.
##
## See: listener.tcp.$name.send_timeout_close
##
## Value: on | off
listener.ws.external.send_timeout_close = on

## The TCP receive buffer(os kernel) for external MQTT/WebSocket connections.
##
## See: listener.tcp.$name.recbuf
##
## Value: Bytes
## listener.ws.external.recbuf = 2KB

## The TCP send buffer(os kernel) for external MQTT/WebSocket connections.
##
## See: listener.tcp.$name.sndbuf
##
## Value: Bytes
## listener.ws.external.sndbuf = 2KB

## The size of the user-level software buffer used by the driver.
##
## See: listener.tcp.$name.buffer
##
## Value: Bytes
## listener.ws.external.buffer = 2KB

## Sets the 'buffer = max(sndbuf, recbuf)' if this option is enabled.
##
## See: listener.tcp.$name.tune_buffer
##
## Value: on | off
## listener.ws.external.tune_buffer = off

## The TCP_NODELAY flag for external MQTT/WebSocket connections.
##
## See: listener.tcp.$name.nodelay
##
## Value: true | false
listener.ws.external.nodelay = true

##--------------------------------------------------------------------
## External WebSocket/SSL listener for MQTT Protocol

## listener.wss.$name is the IP address and port that the MQTT/WebSocket/SSL
## listener will bind.
##
## Value: IP:Port | Port
##
## Examples: 8084, 127.0.0.1:8084, ::1:8084
listener.wss.external = 8084

## The path of WebSocket MQTT endpoint
##
## Value: URL Path
listener.wss.external.mqtt_path = /mqtt

## The acceptor pool for external MQTT/WebSocket/SSL listener.
##
## Value: Number
listener.wss.external.acceptors = 4

## Maximum number of concurrent MQTT/Webwocket/SSL connections.
##
## Value: Number
listener.wss.external.max_connections = 16

## Maximum MQTT/WebSocket/SSL connections per second.
##
## See: listener.tcp.$name.max_conn_rate
##
## Value: Number
listener.wss.external.max_conn_rate = 1000

## Rate limit for the MQTT/WebSocket/SSL connections.
##
## Value: rate,burst
## Unit: Bps
## listener.wss.external.rate_limit = 1024,4096

## Zone of the external MQTT/WebSocket/SSL listener belonged to.
##
## Value: String
listener.wss.external.zone = external

## Mountpoint of the MQTT/WebSocket/SSL Listener.
##
## See: listener.tcp.$name.mountpoint
##
## Value: String
## listener.wss.external.mountpoint = devicebound/

## The access control rules for the MQTT/WebSocket/SSL listener.
##
## See: listener.tcp.$name.access.<no>
##
## Value: ACL Rule
listener.wss.external.access.1 = allow all

## See: listener.ws.external.verify_protocol_header
##
## Value: on | off
listener.wss.external.verify_protocol_header = on

## See: listener.ws.external.proxy_address_header
##
## Value: String
## listener.wss.external.proxy_address_header = X-Forwarded-For

## See: listener.ws.external.proxy_port_header
##
## Value: String
## listener.wss.external.proxy_port_header = X-Forwarded-Port

## Enable the Proxy Protocol V1/2 support.
##
## See: listener.tcp.$name.proxy_protocol
##
## Value: on | off
## listener.wss.external.proxy_protocol = on

## Sets the timeout for proxy protocol.
##
## See: listener.tcp.$name.proxy_protocol_timeout
##
## Value: Duration
## listener.wss.external.proxy_protocol_timeout = 3s

## TLS versions only to protect from POODLE attack.
##
## See: listener.ssl.$name.tls_versions
##
## Value: String, seperated by ','
## listener.wss.external.tls_versions = tlsv1.2,tlsv1.1,tlsv1

## Path to the file containing the user's private PEM-encoded key.
##
## See: listener.ssl.$name.keyfile
##
## Value: File
listener.wss.external.keyfile = etc/certs/key.pem

## Path to a file containing the user certificate.
##
## See: listener.ssl.$name.certfile
##
## Value: File
listener.wss.external.certfile = etc/certs/cert.pem

## Path to the file containing PEM-encoded CA certificates.
##
## See: listener.ssl.$name.cacert
##
## Value: File
## listener.wss.external.cacertfile = etc/certs/cacert.pem

## See: listener.ssl.$name.dhfile
##
## Value: File
## listener.ssl.external.dhfile = etc/certs/dh-params.pem

## See: listener.ssl.$name.vefify
##
## Value: vefify_peer | verify_none
## listener.wss.external.verify = verify_peer

## See: listener.ssl.$name.fail_if_no_peer_cert
##
## Value: false | true
## listener.wss.external.fail_if_no_peer_cert = true

## See: listener.ssl.$name.ciphers
##
## Value: Ciphers
## listener.wss.external.ciphers =

## See: listener.ssl.$name.secure_renegotiate
##
## Value: on | off
## listener.wss.external.secure_renegotiate = off

## See: listener.ssl.$name.reuse_sessions
##
## Value: on | off
## listener.wss.external.reuse_sessions = on

## See: listener.ssl.$name.honor_cipher_order
##
## Value: on | off
## listener.wss.external.honor_cipher_order = on

## See: listener.ssl.$name.peer_cert_as_username
##
## Value: cn | dn | crt
## listener.wss.external.peer_cert_as_username = cn

## TCP backlog for the WebSocket/SSL connection.
##
## See: listener.tcp.$name.backlog
##
## Value: Number >= 0
listener.wss.external.backlog = 1024

## The TCP send timeout for the WebSocket/SSL connection.
##
## See: listener.tcp.$name.send_timeout
##
## Value: Duration
listener.wss.external.send_timeout = 15s

## Close the WebSocket/SSL connection if send timeout.
##
## See: listener.tcp.$name.send_timeout_close
##
## Value: on | off
listener.wss.external.send_timeout_close = on

## The TCP receive buffer(os kernel) for the WebSocket/SSL connections.
##
## See: listener.tcp.$name.recbuf
##
## Value: Bytes
## listener.wss.external.recbuf = 4KB

## The TCP send buffer(os kernel) for the WebSocket/SSL connections.
##
## See: listener.tcp.$name.sndbuf
##
## Value: Bytes
## listener.wss.external.sndbuf = 4KB

## The size of the user-level software buffer used by the driver.
##
## See: listener.tcp.$name.buffer
##
## Value: Bytes
## listener.wss.external.buffer = 4KB

## The TCP_NODELAY flag for WebSocket/SSL connections.
##
## See: listener.tcp.$name.nodelay
##
## Value: true | false
## listener.wss.external.nodelay = true

listener.wss.external.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA

##--------------------------------------------------------------------
## Bridges
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## Bridges to aws
##--------------------------------------------------------------------
## Start type of the bridge.
##
## Value: enum
## manual
## auto
bridge.aws.start_type = manual

## Bridge reconnect time.
##
## Value: Duration
## Default: 30 seconds
bridge.aws.reconnect_interval = 30s

## Bridge address: node name for local bridge, host:port for remote.
##
## Value: String
## Example: emqx@127.0.0.1,  127.0.0.1:1883
bridge.aws.address = 127.0.0.1:1883

## Protocol version of the bridge.
##
## Value: Enum
## - mqttv5
## - mqttv4
## - mqttv3
bridge.aws.proto_ver = mqttv4

## The ClientId of a remote bridge.
##
## Value: String
bridge.aws.client_id = bridge_aws

## The Clean start flag of a remote bridge.
##
## Value: boolean
## Default: true
##
## NOTE: Some IoT platforms require clean_start
##       must be set to 'true'
## bridge.aws.clean_start = true

## The username for a remote bridge.
##
## Value: String
bridge.aws.username = user

## The password for a remote bridge.
##
## Value: String
bridge.aws.password = passwd

## Mountpoint of the bridge.
##
## Value: String
bridge.aws.mountpoint = bridge/aws/${node}/

## Ping interval of a down bridge.
##
## Value: Duration
## Default: 10 seconds
bridge.aws.keepalive = 60s

## Forward message topics
##
## Value: String
## Example: topic1/#,topic2/#
bridge.aws.forwards = topic1/#,topic2/#

## Subscriptions of the bridge topic.
##
## Value: String
bridge.aws.subscription.1.topic = cmd/topic1

## Subscriptions of the bridge qos.
##
## Value: Number
bridge.aws.subscription.1.qos = 1

## Subscriptions of the bridge topic.
##
## Value: String
bridge.aws.subscription.2.topic = cmd/topic2

## Subscriptions of the bridge qos.
##
## Value: Number
bridge.aws.subscription.2.qos = 1

## Bridge message queue message type.
##
## Value: Enum
## Example: memory | disk
bridge.aws.mqueue_type = memory

## The pending message queue of a bridge.
##
## Value: Number
bridge.aws.max_pending_messages = 10000

## Bribge to remote server via SSL.
##
## Value: on | off
bridge.aws.ssl = off

## PEM-encoded CA certificates of the bridge.
##
## Value: File
## bridge.aws.cacertfile = etc/certs/cacert.pem

## Client SSL Certfile of the bridge.
##
## Value: File
## bridge.aws.certfile = etc/certs/client-cert.pem

## Client SSL Keyfile of the bridge.
##
## Value: File
## bridge.aws.keyfile = etc/certs/client-key.pem

## SSL Ciphers used by the bridge.
##
## Value: String
## bridge.aws.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384

## TLS versions used by the bridge.
##
## Value: String
## bridge.aws.tls_versions = tlsv1.2,tlsv1.1,tlsv1

##--------------------------------------------------------------------
## Bridges to azure
##--------------------------------------------------------------------
## Start type of the bridge.
##
## Value: enum
## manual
## auto
## bridge.azure.start_type = manual

## Bridge reconnect count.
##
## Value: Number
## bridge.azure.reconnect_count = 10

## Bridge reconnect time.
##
## Value: Duration
## Default: 30 seconds
## bridge.azure.reconnect_time = 30s

## Bridge address: node name for local bridge, host:port for remote.
##
## Value: String
## Example: emqx@127.0.0.1,  127.0.0.1:1883
## bridge.azure.address = 127.0.0.1:1883

## Protocol version of the bridge.
##
## Value: Enum
## - mqttv5
## - mqttv4
## - mqttv3
## bridge.azure.proto_ver = mqttv4

## The ClientId of a remote bridge.
##
## Value: String
## bridge.azure.client_id = bridge_azure

## The Clean start flag of a remote bridge.
##
## Value: boolean
## Default: true
##
## NOTE: Some IoT platforms require clean_start
##       must be set to 'true'
## bridge.azure.clean_start = true

## The username for a remote bridge.
##
## Value: String
## bridge.azure.username = user

## The password for a remote bridge.
##
## Value: String
## bridge.azure.password = passwd

## Mountpoint of the bridge.
##
## Value: String
## bridge.azure.mountpoint = bridge/azure/${node}/

## Ping interval of a down bridge.
##
## Value: Duration
## Default: 10 seconds
## bridge.azure.keepalive = 10s

## Forward message topics
##
## Value: String
## Example: topic1/#,topic2/#
## bridge.azure.forwards = topic1/#,topic2/#

## Subscriptions of the bridge topic.
##
## Value: String
## bridge.azure.subscription.1.topic = $share/cmd/topic1

## Subscriptions of the bridge qos.
##
## Value: Number
## bridge.azure.subscription.1.qos = 1

## Subscriptions of the bridge topic.
##
## Value: String
## bridge.azure.subscription.2.topic = $share/cmd/topic2

## Subscriptions of the bridge qos.
##
## Value: Number
## bridge.azure.subscription.2.qos = 1

## Bridge store message type.
##
## Value: Enum
## Example: memory | disk
## bridge.azure.store_type = memory

## The pending message queue of a bridge.
##
## Value: Number
## bridge.azure.max_pending_messages = 10000


## PEM-encoded CA certificates of the bridge.
##
## Value: File
## bridge.azure.cacertfile = cacert.pem

## Client SSL Certfile of the bridge.
##
## Value: File
## bridge.azure.certfile = cert.pem

## Client SSL Keyfile of the bridge.
##
## Value: File
## bridge.azure.keyfile = key.pem

## SSL Ciphers used by the bridge.
##
## Value: String
## bridge.azure.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384

## TLS versions used by the bridge.
##
## Value: String
## bridge.azure.tls_versions = tlsv1.2,tlsv1.1,tlsv1

##--------------------------------------------------------------------
## Modules
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## Presence Module

## Enable Presence Module.
##
## Value: on | off
module.presence = on

## Sets the QoS for presence MQTT message.
##
## Value: 0 | 1 | 2
module.presence.qos = 1

##--------------------------------------------------------------------
## Subscription Module

## Enable Subscription Module.
##
## Value: on | off
module.subscription = off

## Subscribe the Topics automatically when client connected.
## module.subscription.1.topic = $client/%c
## Qos of the subscription: 0 | 1 | 2
## module.subscription.1.qos = 1

## module.subscription.2.topic = $user/%u
## module.subscription.2.qos = 1

##--------------------------------------------------------------------
## Rewrite Module

## Enable Rewrite Module.
##
## Value: on | off
module.rewrite = off

## {rewrite, Topic, Re, Dest}
## module.rewrite.rule.1 = x/# ^x/y/(.+)$ z/y/$1
## module.rewrite.rule.2 = y/+/z/# ^y/(.+)/z/(.+)$ y/z/$2

##-------------------------------------------------------------------
## Plugins
##-------------------------------------------------------------------

## The etc dir for plugins' config.
##
## Value: Folder
plugins.etc_dir = etc/plugins/

## The file to store loaded plugin names.
##
## Value: File
plugins.loaded_file = data/loaded_plugins

## File to store loaded plugin names.
plugins.expand_plugins_dir = plugins/

##--------------------------------------------------------------------
## Broker
##--------------------------------------------------------------------

## System interval of publishing $SYS messages.
##
## Value: Duration
## Default: 1m, 1 minute
broker.sys_interval = 1m

## Enable global session registry.
##
## Value: on | off
broker.enable_session_registry = on

## Session locking strategy in a cluster.
##
## Value: Enum
## - local
## - one
## - quorum
## - all
broker.session_locking_strategy = quorum

## Dispatch strategy for shared subscription
##
## Value: Enum
## - random
## - round_robbin
## - sticky
## - hash
broker.shared_subscription_strategy = random

## Enable/disable shared dispatch acknowledgement for QoS1 and QoS2 messages
## This should allow messages to be dispatched to a different subscriber in
## the group in case the picked (based on shared_subscription_strategy) one # is offline
##
## Value: Enum
## - true
## - false
broker.shared_dispatch_ack_enabled = false

## Enable batch clean for deleted routes.
##
## Value: Flag
broker.route_batch_clean = off

##--------------------------------------------------------------------
## System Monitor
##--------------------------------------------------------------------

## Enable Long GC monitoring.
## Notice: don't enable the monitor in production for:
## https://github.com/erlang/otp/blob/feb45017da36be78d4c5784d758ede619fa7bfd3/erts/emulator/beam/erl_gc.c#L421
##
## Value: true | false
sysmon.long_gc = false

## Enable Long Schedule(ms) monitoring.
##
## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
##
## Value: Number
sysmon.long_schedule = 240

## Enable Large Heap monitoring.
##
## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
##
## Value: bytes
##
## Default: 8M words. 32MB on 32-bit VM, 64MB on 64-bit VM.
sysmon.large_heap = 8MB

## Enable Busy Port monitoring.
##
## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
##
## Value: true | false
sysmon.busy_port = false

## Enable Busy Dist Port monitoring.
##
## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
##
## Value: true | false
sysmon.busy_dist_port = true

##--------------------------------------------------------------------
## ClientId Authentication Plugin
##--------------------------------------------------------------------

## Examples
##auth.client.1.clientid = id
##auth.client.1.password = passwd
##auth.client.2.clientid = dev:devid
##auth.client.2.password = passwd2
##auth.client.3.clientid = app:appid
##auth.client.3.password = passwd3
##auth.client.4.clientid = client~!@#$%^&*()_+
##auth.client.4.password = passwd~!@#$%^&*()_+


##--------------------------------------------------------------------
## HTTP Auth/ACL Plugin
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## Authentication request.
##
## Variables:
##  - %u: username
##  - %c: clientid
##  - %a: ipaddress
##  - %P: password
##
## Value: URL
auth.http.auth_req = http://127.0.0.1:8991/mqtt/auth
## Value: post | get | put
auth.http.auth_req.method = post
## Value: Params
auth.http.auth_req.params = clientid=%c,username=%u,password=%P

##--------------------------------------------------------------------
## Superuser request.
##
## Variables:
##  - %u: username
##  - %c: clientid
##  - %a: ipaddress
##
## Value: URL
auth.http.super_req = http://127.0.0.1:8991/mqtt/superuser
## Value: post | get | put
auth.http.super_req.method = post
## Value: Params
auth.http.super_req.params = clientid=%c,username=%u

##--------------------------------------------------------------------
## ACL request.
##
## Variables:
##  - %A: 1 | 2, 1 = sub, 2 = pub
##  - %u: username
##  - %c: clientid
##  - %a: ipaddress
##  - %t: topic
##
## Value: URL
auth.http.acl_req = http://127.0.0.1:8991/mqtt/acl
## Value: post | get | put
auth.http.acl_req.method = get
## Value: Params
auth.http.acl_req.params = access=%A,username=%u,clientid=%c,ipaddr=%a,topic=%t


##--------------------------------------------------------------------
## JWT Auth Plugin
##--------------------------------------------------------------------

## HMAC Hash Secret.
##
## Value: String
auth.jwt.secret = emqxsecret

## RSA or ECDSA public key file.
##
## Value: File
## auth.jwt.pubkey = etc/certs/jwt_public_key.pem


##--------------------------------------------------------------------
## LDAP Auth Plugin
##--------------------------------------------------------------------

## LDAP server list, seperated by ','.
##
## Value: String
auth.ldap.servers = 127.0.0.1

## LDAP server port.
##
## Value: Port
auth.ldap.port = 389

## LDAP pool size
##
## Value: String
auth.ldap.pool = 8

## LDAP Bind DN.
##
## Value: DN
auth.ldap.bind_dn = cn=root,dc=emqx,dc=io

## LDAP Bind Password.
##
## Value: String
auth.ldap.bind_password = public

## LDAP query timeout.
##
## Value: Number
auth.ldap.timeout = 30s

## Device DN.
##
## Variables:
##
## Value: DN
auth.ldap.device_dn = ou=device,dc=emqx,dc=io

## Specified ObjectClass
##
## Variables:
##
## Value: string
auth.ldap.match_objectclass = mqttUser

## attributetype for username
##
## Variables:
##
## Value: string
auth.ldap.username.attributetype = uid

## attributetype for password
##
## Variables:
##
## Value: string
auth.ldap.password.attributetype = userPassword

## Whether to enable SSL.
##
## Value: true | false
auth.ldap.ssl = false

##TODO: SSL Support

## auth.ldap.ssl.certfile = etc/certs/cert.pem

## auth.ldap.ssl.keyfile = etc/certs/key.pem

## auth.ldap.ssl.cacertfile = etc/certs/cacert.pem

## auth.ldap.ssl.verify = verify_peer

## auth.ldap.ssl.fail_if_no_peer_cert = true

##--------------------------------------------------------------------
## MongoDB Auth/ACL Plugin
##--------------------------------------------------------------------

## MongoDB Topology Type.
##
## Value: single | unknown | sharded | rs
auth.mongo.type = single

## The set name if type is rs.
##
## Value: String
## auth.mongo.rs_set_name =

## MongoDB server list.
##
## Value: String
##
## Examples: 127.0.0.1:27017,127.0.0.2:27017...
auth.mongo.server = 127.0.0.1:27017

## MongoDB pool size
##
## Value: Number
auth.mongo.pool = 8

## MongoDB login user.
##
## Value: String
## auth.mongo.login =

## MongoDB password.
##
## Value: String
## auth.mongo.password =

## MongoDB AuthSource
##
## Value: String
## Default: mqtt
## auth.mongo.auth_source = admin

## MongoDB database
##
## Value: String
auth.mongo.database = mqtt

## Whether to enable SSL connection.
##
## Value: true | false
## auth.mongo.ssl = false

## SSL keyfile.
##
## Value: File
## auth.mongo.ssl_opts.keyfile =

## SSL certfile.
##
## Value: File
## auth.mongo.ssl_opts.certfile =

## SSL cacertfile.
##
## Value: File
## auth.mongo.ssl_opts.cacertfile =

## MongoDB write mode.
##
## Value: unsafe | safe
## auth.mongo.w_mode =

## Mongo read mode.
##
## Value: master | slave_ok
## auth.mongo.r_mode =

## MongoDB topology options.
auth.mongo.topology.pool_size = 1
auth.mongo.topology.max_overflow = 0
## auth.mongo.topology.overflow_ttl = 1000
## auth.mongo.topology.overflow_check_period = 1000
## auth.mongo.topology.local_threshold_ms = 1000
## auth.mongo.topology.connect_timeout_ms = 20000
## auth.mongo.topology.socket_timeout_ms = 100
## auth.mongo.topology.server_selection_timeout_ms = 30000
## auth.mongo.topology.wait_queue_timeout_ms = 1000
## auth.mongo.topology.heartbeat_frequency_ms = 10000
## auth.mongo.topology.min_heartbeat_frequency_ms = 1000

## Authentication query.
auth.mongo.auth_query.collection = mqtt_user

## password with salt suffix
## auth.mongo.auth_query.password_hash = sha256,salt

## password with salt prefix
## auth.mongo.auth_query.password_hash = salt,sha256
auth.mongo.auth_query.password_field = password

## Password hash.
##
## Value: plain | md5 | sha | sha256 | bcrypt
auth.mongo.auth_query.password_hash = sha256

## sha256 with salt suffix
## auth.mongo.auth_query.password_hash = sha256,salt

## sha256 with salt prefix
## auth.mongo.auth_query.password_hash = salt,sha256

## bcrypt with salt prefix
## auth.mongo.auth_query.password_hash = salt,bcrypt

## pbkdf2 with macfun iterations dklen
## macfun: md4, md5, ripemd160, sha, sha224, sha256, sha384, sha512
## auth.mongo.auth_query.password_hash = pbkdf2,sha256,1000,20

#auth.mongo.auth_query.selector = username=%u, clientid=%c
auth.mongo.auth_query.selector = username=%u

## Enable superuser query.
auth.mongo.super_query = on

auth.mongo.super_query.collection = mqtt_user

auth.mongo.super_query.super_field = is_superuser

#auth.mongo.super_query.selector = username=%u, clientid=%c
auth.mongo.super_query.selector = username=%u

## Enable ACL query.
auth.mongo.acl_query = on

auth.mongo.acl_query.collection = mqtt_acl

#auth.mongo.acl_query.selector.1 = username=%u,clientid=%c
#auth.mongo.acl_query.selector.2 = username=$all
#auth.mongo.acl_query.selector.3 = clientid=$all
auth.mongo.acl_query.selector = username=%u

##--------------------------------------------------------------------
## MySQL Auth/ACL Plugin
##--------------------------------------------------------------------

## MySQL server address.
##
## Value: Port | IP:Port
##
## Examples: 3306, 127.0.0.1:3306, localhost:3306
auth.mysql.server = 127.0.0.1:3306

## MySQL pool size.
##
## Value: Number
auth.mysql.pool = 8

## MySQL username.
##
## Value: String
## auth.mysql.username =

## MySQL password.
##
## Value: String
## auth.mysql.password =

## MySQL database.
##
## Value: String
auth.mysql.database = mqtt

## Variables: %u = username, %c = clientid

## Authentication query.
##
## Note that column names should be 'password' and 'salt' (if used).
## In case column names differ in your DB - please use aliases,
## e.g. "my_column_name as password".
##
## Value: SQL
##
## Variables:
##  - %u: username
##  - %c: clientid
##
auth.mysql.auth_query = select password from mqtt_user where username = '%u' limit 1
## auth.mysql.auth_query = select password_hash as password from mqtt_user where username = '%u' limit 1

## Password hash.
##
## Value: plain | md5 | sha | sha256 | bcrypt
auth.mysql.password_hash = sha256

## sha256 with salt prefix
## auth.mysql.password_hash = salt,sha256

## bcrypt with salt only prefix
## auth.mysql.password_hash = salt,bcrypt

## sha256 with salt suffix
## auth.mysql.password_hash = sha256,salt

## pbkdf2 with macfun iterations dklen
## macfun: md4, md5, ripemd160, sha, sha224, sha256, sha384, sha512
## auth.mysql.password_hash = pbkdf2,sha256,1000,20

## Superuser query.
##
## Value: SQL
##
## Variables:
##  - %u: username
##  - %c: clientid
auth.mysql.super_query = select is_superuser from mqtt_user where username = '%u' limit 1

## ACL query.
##
## Value: SQL
##
## Variables:
##  - %a: ipaddr
##  - %u: username
##  - %c: clientid
auth.mysql.acl_query = select allow, ipaddr, username, clientid, access, topic from mqtt_acl where ipaddr = '%a' or username = '%u' or username = '$all' or clientid = '%c'


##--------------------------------------------------------------------
## PostgreSQL Auth/ACL Plugin
##--------------------------------------------------------------------

## PostgreSQL server address.
##
## Value: Port | IP:Port
##
## Examples: 5432, 127.0.0.1:5432, localhost:5432
auth.pgsql.server = 127.0.0.1:5432

## PostgreSQL pool size.
##
## Value: Number
auth.pgsql.pool = 8

## PostgreSQL username.
##
## Value: String
auth.pgsql.username = root

## PostgreSQL password.
##
## Value: String
## auth.pgsql.password =

## PostgreSQL database.
##
## Value: String
auth.pgsql.database = mqtt

## PostgreSQL database encoding.
##
## Value: String
auth.pgsql.encoding = utf8

## Whether to enable SSL connection.
##
## Value: true | false
auth.pgsql.ssl = false

## SSL keyfile.
##
## Value: File
## auth.pgsql.ssl_opts.keyfile =

## SSL certfile.
##
## Value: File
## auth.pgsql.ssl_opts.certfile =

## SSL cacertfile.
##
## Value: File
## auth.pgsql.ssl_opts.cacertfile =

## Authentication query.
##
## Value: SQL
##
## Variables:
##  - %u: username
##  - %c: clientid
##
auth.pgsql.auth_query = select password from mqtt_user where username = '%u' limit 1

## Password hash.
##
## Value: plain | md5 | sha | sha256 | bcrypt
auth.pgsql.password_hash = sha256

## sha256 with salt prefix
## auth.pgsql.password_hash = salt,sha256

## sha256 with salt suffix
## auth.pgsql.password_hash = sha256,salt

## bcrypt with salt prefix
## auth.pgsql.password_hash = salt,bcrypt

## pbkdf2 with macfun iterations dklen
## macfun: md4, md5, ripemd160, sha, sha224, sha256, sha384, sha512
## auth.pgsql.password_hash = pbkdf2,sha256,1000,20

## Superuser query.
##
## Value: SQL
##
## Variables:
##  - %u: username
##  - %c: clientid
auth.pgsql.super_query = select is_superuser from mqtt_user where username = '%u' limit 1

## ACL query. Comment this query, the ACL will be disabled.
##
## Value: SQL
##
## Variables:
##  - %a: ipaddress
##  - %u: username
##  - %c: clientid
auth.pgsql.acl_query = select allow, ipaddr, username, clientid, access, topic from mqtt_acl where ipaddr = '%a' or username = '%u' or username = '$all' or clientid = '%c'


##--------------------------------------------------------------------
## Redis Auth/ACL Plugin
##--------------------------------------------------------------------

## Redis server address.
##
## Value: Port | IP:Port
##
## Redis Server: 6379, 127.0.0.1:6379, localhost:6379, Redis Sentinel: 127.0.0.1:26379
auth.redis.server = 127.0.0.1:6379

## Redis sentinel cluster name.
##
## Value: String
## auth.redis.sentinel = mymaster

## Redis pool size.
##
## Value: Number
auth.redis.pool = 8

## Redis database no.
##
## Value: Number
auth.redis.database = 0

## Redis password.
##
## Value: String
## auth.redis.password =

## Authentication query command.
##
## Value: Redis cmd
##
## Variables:
##  - %u: username
##  - %c: clientid
##
## Examples:
##  - HGET mqtt_user:%u password
##  - HMGET mqtt_user:%u password
##  - HMGET mqtt_user:%u password salt
auth.redis.auth_cmd = HMGET mqtt_user:%u password

## Password hash.
##
## Value: plain | md5 | sha | sha256 | bcrypt
auth.redis.password_hash = plain

## sha256 with salt prefix
## auth.redis.password_hash = salt,sha256

## sha256 with salt suffix
## auth.redis.password_hash = sha256,salt

## bcrypt with salt prefix
## auth.redis.password_hash = salt,bcrypt

## pbkdf2 with macfun iterations dklen
## macfun: md4, md5, ripemd160, sha, sha224, sha256, sha384, sha512
## auth.redis.password_hash = pbkdf2,sha256,1000,20

## Superuser query command.
##
## Value: Redis cmd
##
## Variables:
##  - %u: username
##  - %c: clientid
auth.redis.super_cmd = HGET mqtt_user:%u is_superuser

## ACL query command.
##
## Value: Redis cmd
##
## Variables:
##  - %u: username
##  - %c: clientid
auth.redis.acl_cmd = HGETALL mqtt_acl:%u


##--------------------------------------------------------------------
## Username Authentication Plugin
##--------------------------------------------------------------------

## Examples:
##auth.user.1.username = admin
##auth.user.1.password = public
##auth.user.2.username = feng@emqtt.io
##auth.user.2.password = public
##auth.user.3.username = name~!@#$%^&*()_+
##auth.user.3.password = pwsswd~!@#$%^&*()_+

##--------------------------------------------------------------------
## CoAP Gateway
##--------------------------------------------------------------------

## The UDP port that CoAP is listening on.
##
## Value: Port
coap.port = 5683

## Interval for keepalive, specified in seconds.
##
## Value: Duration
##  -s: seconds
##  -m: minutes
##  -h: hours
coap.keepalive = 120s

## Whether to enable statistics for CoAP clients.
##
## Value: on | off
coap.enable_stats = off

## Private key file for DTLS
##
## Value: File
coap.keyfile = etc/certs/key.pem

## Server certificate for DTLS.
##
## Value: File
coap.certfile = etc/certs/cert.pem


##--------------------------------------------------------------------
## EMQ X Dashboard
##--------------------------------------------------------------------

## Dashboard API Providers
##
## Value: String
dashboard.api.providers = emqx_management,emqx_dashboard

## Default user's login name.
##
## Value: String
dashboard.default_user.login = admin

## Default user's password.
##
## Value: String
dashboard.default_user.password = public

##--------------------------------------------------------------------
## HTTP Listener

## The IP address and port that the Dashboard HTTP listener will bind.
##
## Value: Port
##
## Examples: 18083
dashboard.listener.http = 18083

## The acceptor pool for external Dashboard HTTP listener.
##
## Value: Number
dashboard.listener.http.acceptors = 4

## Maximum number of concurrent Dashboard HTTP connections.
##
## Value: Number
dashboard.listener.http.max_clients = 512
##--------------------------------------------------------------------
## HTTPS Listener

## The IP address and port that the Dashboard HTTPS listener will bind.
##
## Value: IP:Port | Port
##
## Examples: 18084, 127.0.0.1:18084, ::1:18084
## dashboard.listener.https = 18084

## The acceptor pool for external Dashboard HTTPS listener.
##
## Value: Number
## dashboard.listener.https.acceptors = 2

## Maximum number of concurrent Dashboard HTTPS connections.
##
## Value: Number
## dashboard.listener.https.max_clients = 512

## Path to the file containing the user's private PEM-encoded key.
##
## Value: File
## dashboard.listener.https.keyfile = etc/certs/key.pem

## Path to a file containing the user certificate.
##
## Value: File
## dashboard.listener.https.certfile = etc/certs/cert.pem

## Path to the file containing PEM-encoded CA certificates.
##
## Value: File
## dashboard.listener.https.cacertfile = etc/certs/cacert.pem

## See: 'listener.ssl.<name>.dhfile' in emq.conf
##
## Value: File
## dashboard.listener.https.dhfile = {{ platform_etc_dir }}/certs/dh-params.pem

## See: 'listener.ssl.<name>.vefify' in emq.conf
##
## Value: vefify_peer | verify_none
## dashboard.listener.https.verify = verify_peer

## See: 'listener.ssl.<name>.fail_if_no_peer_cert' in emq.conf
##
## Value: false | true
## dashboard.listener.https.fail_if_no_peer_cert = true

## TLS versions only to protect from POODLE attack.
##
## Value: String, seperated by ','
## dashboard.listener.https.tls_versions = tlsv1.2,tlsv1.1,tlsv1

## See: 'listener.ssl.<name>.ciphers' in emq.conf
##
## Value: Ciphers
## dashboard.listener.https.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA

## See: 'listener.ssl.<name>.secure_renegotiate' in emq.conf
##
## Value: on | off
## dashboard.listener.https.secure_renegotiate = off

## See: 'listener.ssl.<name>.reuse_sessions' in emq.conf
##
## Value: on | off
## dashboard.listener.https.reuse_sessions = on

## See: 'listener.ssl.<name>.honor_cipher_order' in emq.conf
##
## Value: on | off
## dashboard.listener.https.honor_cipher_order = on


##--------------------------------------------------------------------
## EMQ X Delayed Publish Plugin
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## EMQ X Lua Hook
##--------------------------------------------------------------------


##--------------------------------------------------------------------
## LwM2M Gateway
##--------------------------------------------------------------------

# UDP port of the LwM2M Gateway
lwm2m.port = 5683

# To Limit the range of lifetime, in seconds
lwm2m.lifetime_min = 1
lwm2m.lifetime_max = 86400

# The time window for Q Mode, indicating that after how long time
#   the downlink commands sent to the client will be cached.
#lwm2m.qmode_time_window = 22

# Is this LwM2M Gateway behind a coaproxy?
#lwm2m.lb = coaproxy

# Auto send observer command to device
# on | off
#lwm2m.auto_observe = off

# The topic subscribed by the lwm2m client after it is connected
# Placeholders supported:
#    '%e': Endpoint Name
#    '%a': IP Address
lwm2m.topics.command = lwm2m/%e/dn/#

# The topic to which the lwm2m client's response is published
lwm2m.topics.response = lwm2m/%e/up/resp

# The topic to which the lwm2m client's notify message is published
lwm2m.topics.notify = lwm2m/%e/up/notify

# The topic to which the lwm2m client's register message is published
lwm2m.topics.register = lwm2m/%e/up/resp

# The topic to which the lwm2m client's update message is published
lwm2m.topics.update = lwm2m/%e/up/resp

# Socket options, used for performance tuning
lwm2m.opts.buffer = 1024KB
lwm2m.opts.recbuf = 1024KB
lwm2m.opts.sndbuf = 1024KB
lwm2m.opts.read_packets = 20

# Cert and Key file for DTLS
lwm2m.certfile = etc/certs/cert.pem
lwm2m.keyfile = etc/certs/key.pem

# Dir where the object definition files can be found
lwm2m.xml_dir =  etc/lwm2m_xml

##--------------------------------------------------------------------
## EMQ X Management Plugin
##--------------------------------------------------------------------

## Max Row Limit
management.max_row_limit = 10000

##--------------------------------------------------------------------
## HTTP Listener

management.listener.http = 8080
management.listener.http.acceptors = 2
management.listener.http.max_clients = 512
management.listener.http.backlog = 512
management.listener.http.send_timeout = 15s
management.listener.http.send_timeout_close = on

##--------------------------------------------------------------------
## HTTPS Listener

## management.listener.https = 8081
## management.listener.https.acceptors = 2
## management.listener.https.max_clients = 512
## management.listener.https.backlog = 512
## management.listener.https.send_timeout = 15s
## management.listener.https.send_timeout_close = on
## management.listener.https.certfile = etc/certs/cert.pem
## management.listener.https.keyfile = etc/certs/key.pem
## management.listener.https.cacertfile = etc/certs/cacert.pem
## management.listener.https.verify = verify_peer
## management.listener.https.fail_if_no_peer_cert = true


##--------------------------------------------------------------------
## Recon Plugin
##--------------------------------------------------------------------

## Global GC Interval.
##
## Value: Duration
##  - h: hour
##  - m: minute
##  - s: second
##
## Examples:
##  - 2h:  2 hours
##  - 30m: 30 minutes
##  - 20s: 20 seconds
##
## Defaut: 5m
recon.gc_interval = 5m


##--------------------------------------------------------------------
## Reloader Plugin
##--------------------------------------------------------------------

## Interval of hot code reloading.
##
## Value: Duration
##  - h: hour
##  - m: minute
##  - s: second
##
## Examples:
##  - 2h:  2 hours
##  - 30m: 30 minutes
##  - 20s: 20 seconds
##
## Defaut: 60s
reloader.interval = 60s

## Logfile of reloader.
##
## Value: File
reloader.logfile = reloader.log


##--------------------------------------------------------------------
## EMQ X Retainer
##--------------------------------------------------------------------

## Where to store the retained messages.
##
## Notice that all nodes in the same cluster have to be configured to
## use the same storage_type.
##
## Value: ram | disc | disc_only
##  - ram: memory only
##  - disc: both memory and disc
##  - disc_only: disc only
##
## Default: ram
retainer.storage_type = ram

## Maximum number of retained messages. 0 means no limit.
##
## Value: Number >= 0
retainer.max_retained_messages = 0

## Maximum retained message size.
##
## Value: Bytes
retainer.max_payload_size = 1MB

## Expiry interval of the retained messages. Never expire if the value is 0.
##
## Value: Duration
##  - h: hour
##  - m: minute
##  - s: second
##
## Examples:
##  - 2h:  2 hours
##  - 30m: 30 minutes
##  - 20s: 20 seconds
##
## Defaut: 0
retainer.expiry_interval = 0

##--------------------------------------------------------------------
## MQTT-SN
##--------------------------------------------------------------------

## The UDP port which emq-sn is listening on.
##
## Value: IP:Port | Port
##
## Examples: 1884, 127.0.0.1:1884, ::1:1884
mqtt.sn.port = 1884

## The duration(seconds) that emq-sn broadcast ADVERTISE message through.
##
## Value: Duration
mqtt.sn.advertise_duration = 15s

## The MQTT-SN Gateway id in ADVERTISE message.
##
## Value: Number
mqtt.sn.gateway_id = 1

## To control whether write statistics data into ETS table for dashbord to read.
##
## Value: on | off
mqtt.sn.enable_stats = off

## To control whether accept and process the received publish message with qos=-1.
##
## Value: on | off
mqtt.sn.enable_qos3 = off

## MQTT SN idle timeout, specified in seconds.
##
## Value: Duration
mqtt.sn.idle_timeout = 30s

## The pre-defined topic name corresponding to the pre-defined topic id of N.
## Note that the pre-defined topic id of 0 is reserved.
mqtt.sn.predefined.topic.0 = reserved
mqtt.sn.predefined.topic.1 = /predefined/topic/name/hello
mqtt.sn.predefined.topic.2 = /predefined/topic/name/nice

## Default username for MQTT-SN. This parameter is optional. If specified,
## emq-sn will connect EMQ core with this username. It is useful if any auth
## plug-in is enabled.
##
## Value: String
mqtt.sn.username = mqtt_sn_user

## This parameter is optional. Pair with username above.
##
## Value: String
mqtt.sn.password = abc


##--------------------------------------------------------------------
## Statsd for EMQ X
##--------------------------------------------------------------------

statsd.push.gateway.server = http://127.0.0.1:9091

statsd.interval = 15000

#prometheus.collector.1 = emqx_statsd

##--------------------------------------------------------------------
## Stomp Plugin
##--------------------------------------------------------------------

##--------------------------------------------------------------------
## Stomp listener

## The Port that stomp listener will bind.
##
## Value: Port
stomp.listener = 61613

## The acceptor pool for stomp listener.
##
## Value: Number
stomp.listener.acceptors = 4

## Maximum number of concurrent stomp connections.
##
## Value: Number
stomp.listener.max_clients = 512

## Whether to enable SSL.
##
## Value: on | off
## stomp.listener.ssl = off

## Path to the file containing the user's private PEM-encoded key.
##
## Value: File
## stomp.listener.keyfile = etc/certs/key.pem

## Path to a file containing the user certificate.
##
## Value: File
## stomp.listener.certfile = etc/certs/cert.pem

## Path to the file containing PEM-encoded CA certificates.
##
## Value: File
## stomp.listener.cacertfile = etc/certs/cacert.pem

## See: 'listener.ssl.<name>.dhfile' in emq.conf
##
## Value: File
## stomp.listener.dhfile = etc/certs/dh-params.pem

## See: 'listener.ssl.<name>.vefify' in emq.conf
##
## Value: vefify_peer | verify_none
## stomp.listener.verify = verify_peer

## See: 'listener.ssl.<name>.fail_if_no_peer_cert' in emq.conf
##
## Value: false | true
## stomp.listener.fail_if_no_peer_cert = true

## TLS versions only to protect from POODLE attack.
##
## Value: String, seperated by ','
## stomp.listener.tls_versions = tlsv1.2,tlsv1.1,tlsv1

## SSL Handshake timeout.
##
## Value: Duration
## stomp.listener.handshake_timeout = 15s

## See: 'listener.ssl.<name>.ciphers' in emq.conf
##
## Value: Ciphers
## stomp.listener.ciphers = ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA

## See: 'listener.ssl.<name>.secure_renegotiate' in emq.conf
##
## Value: on | off
## stomp.listener.secure_renegotiate = off

## See: 'listener.ssl.<name>.reuse_sessions' in emq.conf
##
## Value: on | off
## stomp.listener.reuse_sessions = on

## See: 'listener.ssl.<name>.honor_cipher_order' in emq.conf
##
## Value: on | off
## stomp.listener.honor_cipher_order = on

##--------------------------------------------------------------------
## Stomp login user and password

## Default login user
##
## Value: String
stomp.default_user.login = guest

## Default login password
##
## Value: String
stomp.default_user.passcode = guest

## Allow anonymous authentication.
##
## Value: true | false
stomp.allow_anonymous = true

##--------------------------------------------------------------------
## Stomp frame

## Maximum numbers of frame headers.
##
## Value: Number
stomp.frame.max_headers = 10

## Maximum length of frame header.
##
## Value: Number
stomp.frame.max_header_length = 1024

## Maximum body length of frame.
##
## Value: Number
stomp.frame.max_body_length = 8192



web.hook.api.url = http://127.0.0.1:8080

web.hook.rule.client.connected.1     = {"action": "on_client_connected"}
web.hook.rule.client.disconnected.1  = {"action": "on_client_disconnected"}
web.hook.rule.client.subscribe.1     = {"action": "on_client_subscribe"}
web.hook.rule.client.unsubscribe.1   = {"action": "on_client_unsubscribe"}
web.hook.rule.session.created.1      = {"action": "on_session_created"}
web.hook.rule.session.subscribed.1   = {"action": "on_session_subscribed"}
web.hook.rule.session.unsubscribed.1 = {"action": "on_session_unsubscribed"}
web.hook.rule.session.terminated.1   = {"action": "on_session_terminated"}
web.hook.rule.message.publish.1      = {"action": "on_message_publish"}
web.hook.rule.message.delivered.1    = {"action": "on_message_delivered"}
web.hook.rule.message.acked.1        = {"action": "on_message_acked"}

